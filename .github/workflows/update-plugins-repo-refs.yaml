name: Update plugins repository references
on:
  workflow_call:
    inputs:
      regexps:
        type: string
        required: true
      
      overlay-repo:
        type: string
        required: true
      
      release-branch-pattern:
        type: string
        required: true

      single-branch:
        type: string
        required: false
        default: ""
  
      verbose:
        type: boolean
        required: false
        default: false

      debug:
        type: boolean
        required: false
        default: false
 
      allow-workspace-addition:
        type: boolean

      pr-to-update:
        type: string
        required: false
        default: ""

      workspace-path:
        type: string
        required: false
        default: ""
        
jobs:
 
  prepare:
    runs-on: ubuntu-latest

    name: Prepare 
    outputs:
      workspace-keys: ${{ steps.gather-workspaces.outputs.workspace-keys }}

    steps:
      - name: Use node.js 20.x
        uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8 # v4.0.2
        with:
          node-version: 20.x
          registry-url: https://registry.npmjs.org/ # Needed for auth

      - uses: actions/checkout@v4.2.2      

      - name: Get published community plugins
        id: get-published-community-plugins
        shell: bash {0}
        env:
          INPUT_REGEXPS: ${{ inputs.regexps }}
          INPUT_OVERLAY_REPO: ${{ inputs.overlay-repo }}
          INPUT_RELEASE_BRANCH_PATTERN: ${{ inputs.release-branch-pattern }}
          INPUT_WORKSPACE_PATH: ${{ inputs.workspace-path }}
          INPUT_SINGLE_BRANCH: ${{ inputs.single-branch }}
          INPUT_VERBOSE: ${{ inputs.verbose }}
          INPUT_DEBUG: ${{ inputs.debug }}
          GH_TOKEN: ${{ github.token }}

        run: |
          # Plugin Retrieval

          function message() {
            echo "$1" >&2
          }

          function verbose() {
            if [[ "${INPUT_VERBOSE}" == "true" ]]
            then
              message "$1"
            fi
          }

          if [[ "${INPUT_DEBUG}" == "true" ]]
          then
            set -x
          fi

          set -o pipefail
          npm install semver -g
          overlayRepoBranchesString=$(gh api repos/${INPUT_OVERLAY_REPO}/branches | jq -r --arg regex "${INPUT_RELEASE_BRANCH_PATTERN}" --arg singleBranchPattern "^${INPUT_SINGLE_BRANCH}$" '.[].name | select(test($regex) or test($singleBranchPattern))')
          if [ $? -ne 0 ]
          then
            message "Failed fetching branches"
            exit 1
          fi
          declare -A overlayRepoBranchToBackstageVersion=()
          for overlayRepoBranch in ${overlayRepoBranchesString}
          do
            targetBackstageVersion=$(gh api --header 'Accept: application/vnd.github.v3.raw' "repos/${INPUT_OVERLAY_REPO}/contents/versions.json?ref=${overlayRepoBranch}" --jq .backstage)
            if [ $? -ne 0 ]
            then
              message "Failed fetching supported backstage version"
              exit 1
            fi
            overlayRepoBranchToBackstageVersion[${overlayRepoBranch}]="${targetBackstageVersion}"
          done
          minimalBackstageVersion=$(IFS=$'\n' && echo "${overlayRepoBranchToBackstageVersion[*]}" | sort -V | head -n1)
          message "Minimal considered backstage version: ${minimalBackstageVersion}"

          if [[ "${INPUT_SINGLE_BRANCH}" != "" ]]
          then
            singleBranchBackstageVersion="${overlayRepoBranchToBackstageVersion[${INPUT_SINGLE_BRANCH}]}"
            overlayRepoBranchToBackstageVersion=()
            overlayRepoBranchToBackstageVersion[${INPUT_SINGLE_BRANCH}]="${singleBranchBackstageVersion}"
          fi
          
          message "Watched overlay branches:"
          for overlayRepoBranch in "${!overlayRepoBranchToBackstageVersion[@]}"
          do
            message "  - ${overlayRepoBranch} -> Backstage ${overlayRepoBranchToBackstageVersion[${overlayRepoBranch}]}"
          done

          npmPackages=()
          for regexp in ${INPUT_REGEXPS}
          do
            if [[ "${regexp}" == \'*\' ]]
            then
              message "Using raw plugin name: ${regexp}"
              npmPackages+=("$(echo ${regexp} | sed -e 's/^.//' -e 's/.$//')")
            else
              message "Searching plugins for regexp: ${regexp}"
              npmPackages+=($(npm search "/^(${regexp})/" --searchlimit=1000 --json --no-description --searchexclude "/^(?!(${regexp}))/" | jq -r '.[].name' | sort))
            fi
          done

          missingPackages=()
          publishedPlugins=()
          processPackage() {
            local packageName=$1
            local searchForMissingPackages=$2
            if [[ "${packageName}" == *"-node" ]] || [[ "${packageName}" == *"-common" ]] || [[ "${packageName}" == *"-react" ]] 
            then
              verbose "  Skipping published package ${packageName}: not a plugin"
              return
            fi
            npmPackage=$(npm view --json ${packageName} name backstage versions)
            if [[ "$(echo ${npmPackage} | jq -r '.backstage.role')" != *"-plugin"* ]]
            then
              verbose "  Skipping published package ${packageName}: not a plugin"
              return
            fi
            firstVersionAnalyzed=false
            message "  Fetching published versions of plugin ${packageName}"
            for version in $(echo ${npmPackage} | jq -r '.versions | if type == "string" then . else .[] end | select(test("[^-]+-.+")|not)' | sort -Vr)
            do
              pluginInfo=$(npm view --json ${packageName}@${version} name version gitHead repository  | jq '. | {name, version, directory: (.repository.directory // "."), url: (.repository.url // ""), gitHead }')
              gitRepo=$(echo ${pluginInfo} | jq -r '.url | 
                if (. | startswith("https://github.com/")) then (. | sub("https://github.com/(?<name>.*)"; "\(.name)"))
                elif (. | startswith("git+https://github.com/")) then (. | sub("git\\+https://github.com/(?<name>[^.]+)(\\.git)?"; "\(.name)"))
                elif (. | startswith("git+ssh://git@github.com/")) then (. | sub("git\\+ssh://git@github.com/(?<name>[^.]+)(\\.git)?"; "\(.name)"))
                elif (. | startswith("github:")) then (. | sub("github:(?<name>.*)"; "\(.name)"))
                elif (. | test("[^:/]+/[^:/]+")) then .
                else ""
                end')
              if [[ "${gitRepo}" == "" ]]
              then
                message "    Skipping published plugin ${packageName}@${version}, since sources are not on GitHub."
                continue
              fi
              flat="false"
              workspace=$(echo ${pluginInfo} | jq -r '.directory |
                if (. | startswith("workspaces/"))
                then (. | sub("workspaces/(?<name>[^/]*)/plugins/.*"; "\(.name)"))
                else ""
                end')
              workspacePath="workspaces/${workspace}/"
              backstageJsonPath="${workspacePath}backstage.json"
              if [[ "${workspace}" == "" ]]
              then
                workspacePath="/"
                workspace=$(echo ${gitRepo} | sed 's:.*/\([^/]*\)$:\1:')
                backstageJsonPath="backstage.json"
                if [[ "${gitRepo}" == "backstage/backstage" ]]
                then
                  backstageJsonPath="package.json"
                fi                   
                flat="true"
              fi
              if [[ "${INPUT_WORKSPACE_PATH}" != "" && "${INPUT_WORKSPACE_PATH}/" != "${workspacePath}" ]]
              then
                message "    Skipping published plugin ${packageName}: not part of workspace ${INPUT_WORKSPACE_PATH}"
                break
              fi

              gitHead=$(echo ${pluginInfo} | jq -r '.gitHead // ""')
              if [[ "${gitHead}" == "" ]]
              then
                message "    Skipping published plugin ${packageName}@${version}: gitHead is not set on the NPM package"
                continue
              fi
              
              backstageVersion=$(gh api --header 'Accept: application/vnd.github.v3.raw' "repos/${gitRepo}/contents/${backstageJsonPath}?ref=${gitHead}" --jq .version)
              if [ $? -ne 0 ]
              then
                message "    Skipping published plugin ${packageName}@${version}: Cannot check backstage version "
                continue
              fi

              if [[ "${backstageVersion}" != "${minimalBackstageVersion}" && "${backstageVersion} ${minimalBackstageVersion}" == "$(echo $(semver ${backstageVersion} ${minimalBackstageVersion}))" ]]
              then
                message "    Skipping published plugin ${packageName}@${version} and earlier: Backstage version ${backstageVersion} too old"
                break
              fi

              if [[ "${searchForMissingPackages}" == "true" && ${firstVersionAnalyzed} == "false" ]]
              then
                missingPackageSearchFailed=false
                pluginPackageFiles=$(gh api -X GET "repos/${gitRepo}/git/trees/${gitHead}" -F recursive=true --jq "[ .tree[] | select(.type == \"blob\" and (.path | test(\"^${workspacePath}plugins/.*/package.json$\"))) | select(.path | test(\"(-node|-common|-react)/package.json$\") | not) | .path ]")
                if [ $? -ne 0 ]
                then
                  message "    Failed fetching contents of '${workspacePath}plugins'"
                  missingPackageSearchFailed=true
                else
                  query=$(echo "${pluginPackageFiles}" | jq -r --arg gitHead "${gitHead}" '
                    to_entries
                    | map("f\(.key): object(expression: \"\($gitHead):\(.value)\") { ... on Blob { text } }")
                    | "query($owner: String!, $repo: String!) { repository(owner: $owner, name: $repo) { \(join(" ")) } }"
                  ')

                  foundPackageNames=$(gh api graphql -F owner="${gitRepo%/*}" -F repo="${gitRepo#*/}" -f query="${query}" | jq -r -c '
                      .data.repository | to_entries 
                      | map({
                          "content": (.value.text | fromjson)
                        })
                      | .[]
                      | .content.name
                  ')
                  if [ $? -ne 0 ]
                  then
                    message "    GraphQL query or processing failed."
                    missingPackageSearchFailed=true
                  else
                    # Final loop over ALL discovered packages.
                    while IFS= read -r foundPackageName
                    do
                      # Check if foundPackageName is in either npmPackages or missingPackages arrays
                      found="false"
                      for pkg in "${npmPackages[@]}" "${missingPackages[@]}"; do
                        if [[ "$pkg" == "$foundPackageName" ]]
                        then
                          found="true"
                          break
                        fi
                      done
                      if [[ "$found" == "false" ]]
                      then
                        message "    Adding a missed package: ${foundPackageName}"
                        missingPackages+=("${foundPackageName}")
                      fi
                    done <<< "${foundPackageNames}"
                  fi
                fi
                if [[ "${missingPackageSearchFailed}" == "true" ]]
                then
                  continue
                fi
              fi
              firstVersionAnalyzed=true

              verbose "    Adding plugin ${packageName}@${version} to the list of published plugins"
              addedFields="{\"workspace\":\"$workspace\", \"backstageVersion\": \"$backstageVersion\", \"repo\": \"$gitRepo\", \"flat\": $flat}"
              publishedPlugin=$(echo "${pluginInfo}" | jq ".+= $addedFields")
              publishedPlugins+=("${publishedPlugin}")
            done
          }

          for packageName in "${npmPackages[@]}"
          do
            if [[ "${packageName}" == "" ]]
            then
              continue
            fi
            processPackage ${packageName} 'true'
          done
          message "Processing missed packages"
          for packageName in "${missingPackages[@]}"
          do
            if [[ "${packageName}" == "" ]]
            then
              continue
            fi
            processPackage ${packageName} 'false'
          done

          plugins=$(
            echo '['
            for overlayRepoBranch in "${!overlayRepoBranchToBackstageVersion[@]}"
            do
              targetBackstageVersion="${overlayRepoBranchToBackstageVersion[${overlayRepoBranch}]}"
              local -A matchTypes=()
              local -A matchBackstageVersions=()
              for plugin in "${publishedPlugins[@]}"
              do
                pluginName=$(echo ${plugin} | jq -r '.name')
                backstageVersion=$(echo ${plugin} | jq -r '.backstageVersion')
                version=$(echo ${plugin} | jq -r '.version')
                matchType=""
                if [[ "${targetBackstageVersion}" == "$(semver -r ~${backstageVersion} ${targetBackstageVersion})" ]]
                then
                  matchType="exact"
                elif [[ "${targetBackstageVersion}" == "$(semver -r ^${backstageVersion} ${targetBackstageVersion})" ]]
                then
                  matchType="best-effort"
                fi
                if [[ "${matchType}" == "" ]]
                then
                  verbose "    Skipping published plugin ${pluginName}@${version} for branch ${overlayRepoBranch}, since the underlying Backstage version ${backstageVersion} is not compatible"
                  continue
                fi

                if [[ "${matchTypes[${pluginName}]}" == "" ]]
                then
                  matchTypes[${pluginName}]="${matchType}"
                  matchBackstageVersions[${pluginName}]="${backstageVersion}"
                elif [[ "${matchTypes[${pluginName}]}" != "${matchType}" ]]
                then
                  verbose "    Skipping published plugin ${pluginName}@${version} for branch ${overlayRepoBranch} (with '${matchType}' backstage compatibility type), because a newer plugin version has already been selected with a different backstage compatibility type (${matchTypes[${pluginName}]})"
                  continue
                elif [[ "${backstageVersion}" != "${matchBackstageVersions[${pluginName}]}" ]]
                then
                  verbose "    Skipping published plugin ${pluginName}@${version} for branch ${overlayRepoBranch} (compatible with backstage ${targetBackstageVersion}), because a newer plugin version has already been selected with a different underlying Backstage version (${matchBackstageVersions[${pluginName}]})"
                  continue
                fi

                message "    Plugin ${pluginName}@${version} selected for export for branch ${overlayRepoBranch} and backstage ${targetBackstageVersion}"
                pluginWithBranch=$(echo ${plugin} | jq ".+= {\"branch\": \"${overlayRepoBranch}\", \"matchType\": \"${matchType}\"}")
                echo -n "${comma} ${pluginWithBranch}"
                comma=','
              done
            done
            echo ']'
          )

          message "Plugins to analyze:"
          message "$plugins"
          echo "$plugins" | jq -c > published-plugins.json

      - name: Gather Workspaces
        id: gather-workspaces
        shell: bash
        run: |
          if [[ "${{ inputs.debug }}" == "true" ]]
          then
            set -x
          fi

          # Gather the plugins per workspace and overlay branch,
          # selecting the latest semantic version of each plugin.

          plugins=$(cat published-plugins.json)

          # First, check for mixed backstage versions among the plugins of each workspace,
          # and output a warning if mixed backstage versions are found.

          echo "${plugins}" | jq -r '
            group_by(.branch + "__" + .workspace)
            | map(
                select(
                  (
                    group_by(.name)       | map(sort_by(.version | split(".") | map(tonumber)) | last)
                    | group_by(.directory)| map(sort_by(.version | split(".") | map(tonumber)) | last)
                    | map(.backstageVersion) | unique | length
                  ) > 1
                )
                | "::warning title="
                  + (.[0].branch + "__" + .[0].workspace)
                  + "::mixed backstage versions in workspace plugins: "
                  + (
                      group_by(.name)       | map(sort_by(.version | split(".") | map(tonumber)) | last)
                      | group_by(.directory)| map(sort_by(.version | split(".") | map(tonumber)) | last)
                      | map(.backstageVersion) | unique | join(", ")
                    )
              )
            | .[]
          '

          # Then, group the plugins by workspace and branch, and
          # bring back at the workspace level some fields common to all plugins.
          # The top-level backstage version is the latest backstage version of all plugins.

          workspaces=$(echo "$plugins" | jq -c '
            group_by(.branch + "__" + .workspace)
            | map({
                ((.[0].branch + "__" + .[0].workspace)): {
                  "workspace": .[0].workspace,
                  "branch": .[0].branch,
                  "backstageVersion":
                    (
                      group_by(.name)       | map(sort_by(.version | split(".") | map(tonumber)) | last)
                      | group_by(.directory)| map(sort_by(.version | split(".") | map(tonumber)) | last)
                      | map(.backstageVersion) | unique | sort_by(split(".") | map(tonumber)) | last
                    ),
                  "repo": .[0].repo,
                  "flat": .[0].flat,
                  "plugins":
                    (
                      group_by(.name)       | map(sort_by(.version | split(".") | map(tonumber)) | last)
                      | group_by(.directory)| map(sort_by(.version | split(".") | map(tonumber)) | last)
                    )
                }
              }
            ) | add
          ')

          # Finally, prepare outputs for the next steps.

          if [[ "$workspaces" == "null" ]]
          then
            echo "No workspace found"
            echo "{}" > workspaces.json
            echo "workspace-keys=[]" >> $GITHUB_OUTPUT
            echo "#### No workspace found" >> $GITHUB_STEP_SUMMARY
            echo "The workflow didn't find any workspace compatible with the expected backstage version and elligible for dynamic plugin export." >> $GITHUB_STEP_SUMMARY
            echo "For more details about the reason, look into the logs of the \`Update\` job." >> $GITHUB_STEP_SUMMARY
          else
            echo "Workspaces:"
            echo "$workspaces"

            echo "$workspaces" | jq -c > workspaces.json
            echo "workspace-keys=$(echo $workspaces | jq -c keys)" >> $GITHUB_OUTPUT
          fi

      - name: Upload workspaces json file
        uses: actions/upload-artifact@v4
        with:
          name: workspaces
          path: workspaces.json
              
  update:
    name: Update
    
    needs: prepare
    runs-on: ubuntu-latest
    if: ${{ needs.prepare.outputs.workspace-keys != '[]' }} 
    strategy:
      fail-fast: false
      matrix:
        workspace: ${{ fromJSON(needs.prepare.outputs.workspace-keys) }}
      max-parallel: 1
    
    steps:

      - uses: actions/checkout@v4.2.2

      - name: Download workspaces json file
        uses: actions/download-artifact@v4
        with:
          name: workspaces

      - name: Get workspace JSON
        id: get-workspace-json
        shell: bash
        run: |
          workspace="$(cat workspaces.json | jq '.["${{ matrix.workspace }}"]')"
          echo "Workspace:"
          echo "${workspace}"

          echo workspace=$(echo "${workspace}" | jq -c) >> $GITHUB_OUTPUT

      - name: Get workspace Commit ID
        id: get-workspace-commit-id        
        shell: bash {0}
        env:
          INPUT_WORKSPACE: ${{ steps.get-workspace-json.outputs.workspace }}
        run: |
          if [[ "${{ inputs.debug }}" == "true" ]]
          then
            set -x
          fi
          
          repository=$(echo "${INPUT_WORKSPACE}" | jq -r '.repo')
          commits=$(echo "${INPUT_WORKSPACE}" | jq -r '[ .plugins[] | .gitHead ] | unique | .[]')
          pluginDirectories=$(echo "${INPUT_WORKSPACE}" | jq -r '.plugins[] | .directory')
          if [[ $(echo ${commits} | wc -w) == 1 ]]
          then
            workspaceCommit="${commits}"
          else
            workspaceCommit=""
            for commit in ${commits}
            do
              for pluginDirectory in ${pluginDirectories}
              do
                workspaceVersion=$(echo "${INPUT_WORKSPACE}" | jq -r ".plugins[] | select(.directory == \"${pluginDirectory}\") | .version")
                pluginName=$(echo "${INPUT_WORKSPACE}" | jq -r ".plugins[] | select(.directory == \"${pluginDirectory}\") | .name")

                url="https://raw.githubusercontent.com/${repository}/${commit}/${pluginDirectory}/package.json"
                packageJson=$(curl -fs ${url})
                if [ $? -ne 0 ]
                then
                  echo "Failed fetching : '${url}'"
                  echo "Skipping plugin '${pluginName}' since its source package description is not found"
                  continue
                fi

                version=$(echo "${packageJson}" | jq -r '.version')
                if [[ "${version}" != "${workspaceVersion}" ]]
                then
                  echo "Skipping commit ${commit}: plugin ${pluginName} version not the latest version: ${version} != ${workspaceVersion}"
                  continue 2
                fi
              done
              if [[ "${workspaceCommit}" != "" ]]
              then
                echo "Cannot decide between workspace commits: ${commit} and ${workspaceCommit}"
                break 2
              fi
              workspaceCommit="${commit}"
            done
          fi
          echo "Workspace commit: ${workspaceCommit}"
          echo "workspace-commit=${workspaceCommit}" >> $GITHUB_OUTPUT
          
      - name: Prepare to create PR if necessary
        id: prepare
        uses: actions/github-script@v7
        env:
          INPUT_WORKSPACE: ${{ steps.get-workspace-json.outputs.workspace }}
          INPUT_COMMIT_ID: ${{ steps.get-workspace-commit-id.outputs.workspace-commit }}
        with:
          script: |
            const workspaceJson = core.getInput('workspace');
            const workspace = JSON.parse(workspaceJson);
            core.setOutput('overlay-repo-branch-name', workspace.branch);
            core.setOutput('target-pr-branch-name', 'workspaces/${{ matrix.workspace }}');
            core.setOutput('backstage-version', workspace.backstageVersion);
            core.setOutput('match-type', workspace.matchType);
            core.setOutput('workspace-name', workspace.workspace);
            core.setOutput('workspace-commit', core.getInput('commit_id'));
            core.setOutput('plugins-repo', workspace.repo);
            core.setOutput('plugins-repo-flat', workspace.flat);
            core.setOutput('plugin-directories', workspace.plugins.map((plugin) => plugin.directory).join('\n'));
            return {};

      - name: Create PR if necessary
        id: create-pr-if-necessary
        uses: redhat-developer/rhdh-plugin-export-utils/update-overlay@main
        with:
          overlay-repo: ${{ inputs.overlay-repo }}
          overlay-repo-branch-name: ${{ steps.prepare.outputs.overlay-repo-branch-name }}
          target-pr-branch-name: ${{ steps.prepare.outputs.target-pr-branch-name }}
          backstage-version: ${{ steps.prepare.outputs.backstage-version }}
          match-type: ${{ steps.prepare.outputs.match-type }}
          workspace-name: ${{ steps.prepare.outputs.workspace-name }}
          workspace-commit: ${{ steps.prepare.outputs.workspace-commit }}
          plugins-repo: ${{ steps.prepare.outputs.plugins-repo }}
          plugins-repo-flat: ${{ steps.prepare.outputs.plugins-repo-flat }}
          plugin-directories: ${{ steps.prepare.outputs.plugin-directories }}
          allow-workspace-addition: ${{ inputs.allow-workspace-addition }}
          pr-to-update: ${{ inputs.pr-to-update }}
    
    permissions:
      contents: write
      pull-requests: write
